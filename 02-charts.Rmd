# Chart types {#charts}

## Alternatives to a Box Plot

A box plot is probably the most commonly used chart type to compare distribution of several groups, at least in the scientific literature. Box plots are great, but they can be so incredibly boring. Also, even if you are used to looking at box plots, remember there might be plenty people looking at your plot that have never seen a box and whisker plot before.

A box-and-whisker plot (sometimes called simply a box plot) is a histogram-like method of displaying data, invented by J. Tukey.  The thick **middle line** notates the median, also known as quartile. The limits of the **box** are determined by the lower and upper quartiles, *Q¹* and *Q³*. The box contains thus 50% of the data and is called *"interquartile range"* (IQR). The length of the **whiskers** is determined by the most extreme values that are not considered as outliers (i.e. values that are within 3/2 times the interquartile range).

```{r img-boxplot, fig.cap="A boxplot is a standardized way of displaying the dataset based on a five-number summary: the minimum, the maximum, the sample median, and the first and third quartiles."}
knitr::include_graphics("img/boxplot.png")
```


There are alternatives, but first we are plotting a common box plot:

```{r boxplot, fig.cap="A box plot generated with `{ggplot2}` with customized axis labels and colors."}
g <-
  ggplot(chic, aes(x = season, y = o3,
                   color = season)) +
    labs(x = "Season", y = "Ozone") +
    scale_color_brewer(palette = "Dark2", guide = "none")

g + geom_boxplot()
```


### Dot Plots

Let's plot just each data point of the raw data:

```{r point, fig.cap="A dot plot visualizing the distribution of the raw data as an alternative to boxplots. However, the summary statistics are not shown anymore."}
g + geom_point()
```

Not only boring but uninformative. To improve the plot, one could add transparency to deal with overplotting:

```{r point-alpha, fig.cap="A dot plot with added transparency as an approach to make overlapping data points visible."}
g + geom_point(alpha = .1)
```

However, setting transparency is difficult here since either the overlap is still too high or the extreme values are not visible. Bad, so let's try something else.

### Strip Plots

Try adding a little jitter to the data. I like this for in-house visualization but be careful using jittering because you are purposely adding noise to your data and this can result in misinterpretation of your data.

```{r jitter, fig.cap="A jittered dot plot, also known as strip plot."}
g + geom_jitter(width = .3, alpha = .5)
```

### Violin Plots

Violin plots, similar to box plots except you are using a kernel density to show where you have the most data, are a useful visualization.

```{r violin, fig.cap="Violin plots are a great way to visualize the distribution values, especially in case of large sample sizes."}
g + geom_violin(fill = "gray80", size = 1, alpha = .5)
```

### Combining Violin Plots with Strip Charts

We can of course combine both, estimated densities and the raw data points:

```{r violin-jitter, fig.height=6, fig.cap="A combination of violin and strip plots to visualize the distribution and the raw values at the same time."}
g + geom_violin(fill = "gray80", size = 1, alpha = .5) +
    geom_jitter(alpha = .25, width = .3) +
    coord_flip()
```

The [`{ggforce}` package](https://ggforce.data-imaginist.com/) provides so-called sina functions where the width of the jitter is controlled by the density distribution of the data—that makes the jittering a bit more visually appealing:

```{r violin-sina, fig.cap="A sina plot places the dots according to the distribution and is basically a *raw data violin plot*."}
library(ggforce)

g + geom_violin(fill = "gray80", size = 1, alpha = .5) +
    geom_sina(alpha = .25) +
    coord_flip()
```

### Combining Violin and Box Plots

To allow for easy estimation of quantiles, we can also add the box of the box plot inside the violins to indicate 25%-quartile, median and 75%-quartile:

```{r violin-jitter-box, fig.height=6, fig.cap="A combination of violin and box plots to visualize the distribution and the summary statistics of each group."}
g + geom_violin(aes(fill = season), size = 1, alpha = .5) +
    geom_boxplot(outlier.alpha = 0, coef = 0,
                 color = "gray40", width = .2) +
    scale_fill_brewer(palette = "Dark2", guide = "none") +
    coord_flip()
```


## Create a Rug Representation to a Plot

A rug represents the data of a single quantitative variable, displayed as marks along an axis. In most cases, it is used in addition to scatter plots or heatmaps to visualize the overall distribution of one or both of the variables:

```{r rug, fig.cap="A so-called rug or bardcode plot is a powerful way to highlight the distribution along one axis without requiring much more space."}
ggplot(chic, aes(x = date, y = temp,
                 color = season)) +
  geom_point(show.legend = FALSE) +
  geom_rug(show.legend = FALSE) +
  labs(x = "Year", y = "Temperature (°F)")
```


## Create a Correlation Matrix

There are several packages that allow to create correlation matrix plots, some also using the`{ggplot2}` infrastructure and thus returning ggplots. I am going to show you how to do this without extension packages.

First step is to create the correlation matrix. Here, we use the `{corrr}` package that works nicely with pipes but there are also many others out there. We are using Pearson because all the variables are fairly normally distributed (but you may consider Spearman if your variables follow a different pattern). Note that since a correlation matrix has redundant information we are setting half of it to `NA`.

```{r corr-matrix, echo=-5}
library(tidyverse)

corm <-
  chic %>%
  select(death, temp, dewpoint, pm10, o3) %>%
  corrr::correlate(diagonal = 1) %>%
  corrr::shave(upper = FALSE)

corm
```

Now we put the resulting matrix in **long** format using the `pivot_longer()` function from the `{tidyr}` package:

```{r melt-corr-matrix, echo=-3}
corm <- corm %>%
  pivot_longer(
    cols = -term,
    names_to = "colname",
    values_to = "corr"
  ) %>%
  mutate(rowname = fct_inorder(term),
         colname = fct_inorder(colname))

corm
```

For the plot we will use `geom_tile()` for the heatmap and `geom_text()` for the labels:
 
```{r tile-corr-plot, fig.cap="A basic correlation plot, created with our prepared correlation data set and the help of `geom_tile()`."}
ggplot(corm, aes(rowname, fct_rev(colname),
                 fill = corr)) +
  geom_tile() +
  geom_text(aes(label = round(corr, 2))) +
  coord_fixed() +
  labs(x = NULL, y = NULL)
```

I like to have a diverging color palette, centered at zero correlation, with white indicating missing data. Also I like to have no grid lines and padding around the heatmap as well as nicely formatted labels that are colored depending on the underlying fill:

```{r tile-corr-plot-polished, fig.cap="A polished version of the same correlation plot with custom color palettes and theme adjustments."}
ggplot(corm, aes(rowname, fct_rev(colname),
                 fill = corr)) +
  geom_tile() +
  geom_text(aes(
    label = format(round(corr, 2), nsmall = 2),
    color = abs(corr) < .75
  )) +
  coord_fixed(expand = FALSE) +
  scale_color_manual(values = c("white", "black"),
                     guide = "none") +
  scale_fill_distiller(
    palette = "PuOr", na.value = "white",
    direction = 1, limits = c(-1, 1)
  ) +
  labs(x = NULL, y = NULL) +
  theme(panel.border = element_rect(color = NA, fill = NA),
        legend.position = c(.85, .8))
```
